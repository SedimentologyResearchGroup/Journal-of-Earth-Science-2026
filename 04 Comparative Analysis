#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Comparative Analysis: Single-Stage vs Two-Stage Diagenetic Models
=================================================================

This script performs rigorous comparative analysis between single-stage
and two-stage diagenetic models to demonstrate the superiority of the
two-stage approach for capturing carbonate diagenetic trends.

Key Features:
    - Quantitative RMSE assessment for both models
    - Visual comparison of model pathways
    - Statistical performance metrics

Reference:
    Banner, J.L., & Hanson, G.N. (1990). Calculation of simultaneous isotopic
    and trace element variations during water-rock interaction with applications
    to carbonate diagenesis. Geochimica et Cosmochimica Acta, 54(11), 3123-3137.

Input:
    CSV file with columns: 'Mn/Sr', 'Mn/Fe', 'Sr/Ca'

Output:
    - High-resolution 3-panel comparison figure (300 DPI)
    - Detailed statistical comparison report

Author: [Fei Li]
Date: 2026
License: MIT
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.lines import Line2D
import warnings
import sys

warnings.filterwarnings('ignore')

# ==============================================================================
# MODEL PARAMETERS
# ==============================================================================

# Single-stage model (early diagenesis only, extended W/R range)
SINGLE_STAGE_PARAMS = {
    'name': 'Single-Stage Model',
    'Cs0': {'Sr': 9874.0, 'Mn': 0.735, 'Fe': 164.0, 'Ca': 380000.0},
    'Cf0': {'Sr': 0.15, 'Mn': 6.0, 'Fe': 120.0},
    'D': {'Sr': 0.08, 'Mn': 18.0, 'Fe': 18.0},
    'N_range': [0.01, 300],  # Extended to show limitations
    'color': 'black',
    'linestyle': '--',
    'linewidth': 2.5,
    'alpha': 0.8
}

# Two-stage model - Stage 1: Early diagenesis
STAGE1_PARAMS = {
    'name': 'Early Diagenesis',
    'Cs0': {'Sr': 9874.0, 'Mn': 0.735, 'Fe': 164.0, 'Ca': 380000.0},
    'Cf0': {'Sr': 0.15, 'Mn': 6.0, 'Fe': 120.0},
    'D': {'Sr': 0.08, 'Mn': 18.0, 'Fe': 18.0},
    'N_range': [0.01, 10.0],  # Truncated at W/R = 10
    'color': 'crimson',
    'linestyle': '-',
    'linewidth': 3.0,
    'alpha': 0.9
}

# Two-stage model - Stage 2: Late diagenesis
STAGE2_PARAMS = {
    'name': 'Late Diagenesis',
    'Cs0': {'Sr': 5000.0, 'Mn': 25.0, 'Fe': 140.0, 'Ca': 380000.0},
    'Cf0': {'Sr': 0.05, 'Mn': 15.0, 'Fe': 200.0},
    'D': {'Sr': 0.04, 'Mn': 25.0, 'Fe': 22.0},
    'N_range': [0.5, 200],
    'color': 'dodgerblue',
    'linestyle': '-',
    'linewidth': 3.0,
    'alpha': 0.9
}

TWO_STAGE_MODEL = [STAGE1_PARAMS, STAGE2_PARAMS]

# ==============================================================================
# COMPUTATIONAL FUNCTIONS
# ==============================================================================

def calculate_concentrations(Cs0, Cf0, D, N_values):
    """
    Calculate solid phase concentrations using Banner & Hanson (1990) model.
    
    Parameters:
    -----------
    Cs0, Cf0 : dict
        Initial concentrations in solid and fluid phases
    D : dict
        Partition coefficients
    N_values : array
        Water/rock ratios
        
    Returns:
    --------
    DataFrame with Sr, Mn, Fe concentrations
    """
    results = {'Sr': [], 'Mn': [], 'Fe': []}
    
    for N in N_values:
        s_Sr = (D['Sr'] * (Cs0['Sr'] + N * Cf0['Sr'])) / (D['Sr'] + N)
        s_Mn = (D['Mn'] * (Cs0['Mn'] + N * Cf0['Mn'])) / (D['Mn'] + N)
        s_Fe = (D['Fe'] * (Cs0['Fe'] + N * Cf0['Fe'])) / (D['Fe'] + N)
        
        results['Sr'].append(s_Sr)
        results['Mn'].append(s_Mn)
        results['Fe'].append(s_Fe)
    
    return pd.DataFrame(results)


def get_ternary_coords(mn_sr, mn_fe, sr_ca_scaled):
    """
    Convert ratios to Cartesian coordinates for ternary plotting.
    
    Parameters:
    -----------
    mn_sr, mn_fe, sr_ca_scaled : arrays
        Trace element ratios
        
    Returns:
    --------
    x, y : arrays
        Cartesian coordinates
    """
    total = mn_sr + mn_fe + sr_ca_scaled
    p_mn_sr = mn_sr / total
    p_mn_fe = mn_fe / total
    
    x = 0.5 * p_mn_sr + 1.0 * p_mn_fe
    y = (np.sqrt(3) / 2) * p_mn_sr
    
    return x, y


def calculate_deviations(df, model_stages):
    """
    Calculate minimum Euclidean distance from samples to model curves.
    
    Parameters:
    -----------
    df : DataFrame
        Sample data
    model_stages : list
        List of model stage parameters
        
    Returns:
    --------
    array of minimum distances
    """
    distances = []
    model_curves = []
    
    # Pre-calculate model curves
    for stage in model_stages:
        N_values = np.logspace(
            np.log10(stage['N_range'][0]),
            np.log10(stage['N_range'][1]),
            1000
        )
        
        sim_df = calculate_concentrations(
            stage['Cs0'], stage['Cf0'], stage['D'], N_values
        )
        
        m_mn_sr = sim_df['Mn'] / sim_df['Sr']
        m_mn_fe = sim_df['Mn'] / sim_df['Fe']
        m_sr_ca = (sim_df['Sr'] / stage['Cs0']['Ca']) * 300
        
        mx, my = get_ternary_coords(m_mn_sr.values, m_mn_fe.values, m_sr_ca.values)
        model_curves.append(np.column_stack((mx, my)))
    
    # Calculate distances
    for i in range(len(df)):
        d_mn_sr = df.iloc[i]['Mn/Sr']
        d_mn_fe = df.iloc[i]['Mn/Fe']
        d_sr_ca = df.iloc[i]['Sr/Ca'] * 300
        
        dx, dy = get_ternary_coords(d_mn_sr, d_mn_fe, d_sr_ca)
        data_point = np.array([dx, dy])
        
        min_dist = float('inf')
        for curve in model_curves:
            dists = np.linalg.norm(curve - data_point, axis=1)
            min_dist = min(min_dist, np.min(dists))
        
        distances.append(min_dist)
    
    return np.array(distances)


# ==============================================================================
# PLOTTING FUNCTIONS
# ==============================================================================

def plot_visual_comparison(ax, df):
    """
    Panel A: Visual comparison of model pathways.
    
    Parameters:
    -----------
    ax : matplotlib axis
        Axis for plotting
    df : DataFrame
        Sample data
    """
    # Draw ternary boundaries
    ax.plot([0, 1], [0, 0], 'k-', lw=1.5)
    ax.plot([0.5, 0], [np.sqrt(3)/2, 0], 'k-', lw=1.5)
    ax.plot([0.5, 1], [np.sqrt(3)/2, 0], 'k-', lw=1.5)
    
    # Plot sample data
    data_x, data_y = get_ternary_coords(
        df['Mn/Sr'].values, df['Mn/Fe'].values, df['Sr/Ca'].values * 300
    )
    ax.scatter(data_x, data_y, c='lightgray', s=30, alpha=0.6,
              label='Sample Data', edgecolor='none')
    
    # Plot two-stage model (background)
    for stage in TWO_STAGE_MODEL:
        N_s = np.logspace(np.log10(stage['N_range'][0]),
                         np.log10(stage['N_range'][1]), 200)
        sim = calculate_concentrations(stage['Cs0'], stage['Cf0'], stage['D'], N_s)
        
        tx, ty = get_ternary_coords(
            sim['Mn'] / sim['Sr'],
            sim['Mn'] / sim['Fe'],
            sim['Sr'] / stage['Cs0']['Ca'] * 300
        )
        
        ax.plot(tx, ty, color=stage['color'], ls=stage['linestyle'],
               lw=stage['linewidth'], alpha=stage['alpha'], label=stage['name'])
    
    # Plot single-stage model (foreground)
    N_s = np.logspace(np.log10(SINGLE_STAGE_PARAMS['N_range'][0]),
                     np.log10(SINGLE_STAGE_PARAMS['N_range'][1]), 200)
    sim = calculate_concentrations(
        SINGLE_STAGE_PARAMS['Cs0'],
        SINGLE_STAGE_PARAMS['Cf0'],
        SINGLE_STAGE_PARAMS['D'],
        N_s
    )
    
    sx, sy = get_ternary_coords(
        sim['Mn'] / sim['Sr'],
        sim['Mn'] / sim['Fe'],
        sim['Sr'] / SINGLE_STAGE_PARAMS['Cs0']['Ca'] * 300
    )
    
    ax.plot(sx, sy, color=SINGLE_STAGE_PARAMS['color'],
           ls=SINGLE_STAGE_PARAMS['linestyle'],
           lw=SINGLE_STAGE_PARAMS['linewidth'],
           alpha=SINGLE_STAGE_PARAMS['alpha'],
           label=SINGLE_STAGE_PARAMS['name'], zorder=10)
    
    # Labels
    ax.set_title('(A) Visual Comparison', fontweight='bold', fontsize=12)
    ax.text(0.5, np.sqrt(3)/2 + 0.02, 'Mn/Sr',
           ha='center', fontweight='bold')
    ax.text(-0.02, -0.02, '300Ã—Sr/Ca',
           ha='right', fontweight='bold')
    ax.text(1.02, -0.02, 'Mn/Fe',
           ha='left', fontweight='bold')
    
    ax.axis('off')
    ax.legend(loc='upper right', fontsize=9, framealpha=0.95)


def plot_histogram_comparison(ax, dev_single, dev_two):
    """
    Panel B: Histogram comparison of fit quality.
    
    Parameters:
    -----------
    ax : matplotlib axis
        Axis for plotting
    dev_single, dev_two : arrays
        Deviation values for each model
    """
    bins = np.linspace(0, 0.25, 30)
    
    ax.hist(dev_single, bins=bins, alpha=0.5, color='gray',
           edgecolor='black', lw=0.5,
           label=f"Single-Stage\n(Mean: {np.mean(dev_single):.3f})")
    ax.hist(dev_two, bins=bins, alpha=0.6, color='dodgerblue',
           edgecolor='black', lw=0.5,
           label=f"Two-Stage\n(Mean: {np.mean(dev_two):.3f})")
    
    ax.axvline(0.05, color='green', ls='--', lw=2,
              label='Excellent Fit (<0.05)')
    
    ax.set_xlabel('Model Deviation (RMSE)', fontweight='bold')
    ax.set_ylabel('Frequency', fontweight='bold')
    ax.set_title('(B) Fit Quality Distribution', fontweight='bold', fontsize=12)
    ax.legend(fontsize=9, framealpha=0.95)
    ax.grid(axis='y', ls='--', alpha=0.3)


def plot_cumulative_comparison(ax, dev_single, dev_two, n_samples):
    """
    Panel C: Cumulative performance comparison.
    
    Parameters:
    -----------
    ax : matplotlib axis
        Axis for plotting
    dev_single, dev_two : arrays
        Deviation values for each model
    n_samples : int
        Number of samples
    """
    sorted_single = np.sort(dev_single)
    sorted_two = np.sort(dev_two)
    y_cum = np.arange(1, n_samples + 1) / n_samples * 100
    
    ax.plot(sorted_single, y_cum, color='black', lw=2, ls='--',
           label='Single-Stage')
    ax.plot(sorted_two, y_cum, color='dodgerblue', lw=3,
           label='Two-Stage')
    ax.axvline(0.05, color='green', ls='--',
              label='Excellence Threshold')
    
    # Annotations
    idx_s = np.searchsorted(sorted_single, 0.05)
    pct_s = idx_s / n_samples * 100
    ax.plot(0.05, pct_s, 'ko', markersize=8)
    ax.text(0.06, pct_s - 8, f"{pct_s:.1f}%",
           color='black', fontweight='bold', fontsize=10)
    
    idx_t = np.searchsorted(sorted_two, 0.05)
    pct_t = idx_t / n_samples * 100
    ax.plot(0.05, pct_t, 'bo', markersize=8)
    ax.text(0.06, pct_t + 2, f"{pct_t:.1f}%",
           color='dodgerblue', fontweight='bold', fontsize=10)
    
    ax.set_xlabel('Model Deviation (RMSE)', fontweight='bold')
    ax.set_ylabel('Cumulative %', fontweight='bold')
    ax.set_title('(C) Cumulative Performance', fontweight='bold', fontsize=12)
    ax.set_xlim(0, 0.2)
    ax.set_ylim(0, 105)
    ax.legend(loc='lower right', fontsize=9, framealpha=0.95)
    ax.grid(True, ls='--', alpha=0.3)


# ==============================================================================
# MAIN EXECUTION
# ==============================================================================

def main(csv_file, output_file='model_comparison.png'):
    """
    Main execution function.
    
    Parameters:
    -----------
    csv_file : str
        Path to input CSV file
    output_file : str
        Path to output figure file
    """
    print("\n" + "="*70)
    print("COMPARATIVE ANALYSIS: SINGLE-STAGE VS TWO-STAGE MODELS")
    print("="*70)
    
    try:
        # Load data
        print(f"\n[INFO] Loading data from: {csv_file}")
        df = pd.read_csv(csv_file)
        
        # Validate columns
        required_cols = ['Mn/Sr', 'Mn/Fe', 'Sr/Ca']
        missing_cols = [col for col in required_cols if col not in df.columns]
        
        if missing_cols:
            raise ValueError(f"Missing required columns: {missing_cols}")
        
        print(f"[INFO] Loaded {len(df)} samples successfully")
        
        # Calculate deviations
        print("\n[INFO] Calculating single-stage model deviations...")
        dev_single = calculate_deviations(df, [SINGLE_STAGE_PARAMS])
        
        print("[INFO] Calculating two-stage model deviations...")
        dev_two = calculate_deviations(df, TWO_STAGE_MODEL)
        
        # Statistics
        stats_single = {
            'mean': np.mean(dev_single),
            'median': np.median(dev_single),
            'excellent': np.sum(dev_single < 0.05) / len(df) * 100,
            'good': np.sum(dev_single < 0.10) / len(df) * 100
        }
        
        stats_two = {
            'mean': np.mean(dev_two),
            'median': np.median(dev_two),
            'excellent': np.sum(dev_two < 0.05) / len(df) * 100,
            'good': np.sum(dev_two < 0.10) / len(df) * 100
        }
        
        # Generate figure
        print("\n[INFO] Generating comparison figure...")
        fig = plt.figure(figsize=(18, 6))
        fig.suptitle('Model Comparison: Single-Stage vs Two-Stage',
                    fontsize=16, fontweight='bold', y=1.02)
        
        ax1 = fig.add_subplot(131)
        plot_visual_comparison(ax1, df)
        
        ax2 = fig.add_subplot(132)
        plot_histogram_comparison(ax2, dev_single, dev_two)
        
        ax3 = fig.add_subplot(133)
        plot_cumulative_comparison(ax3, dev_single, dev_two, len(df))
        
        plt.tight_layout()
        plt.savefig(output_file, dpi=300, bbox_inches='tight', facecolor='white')
        
        print(f"[INFO] Figure saved: {output_file}")
        print(f"[INFO] Resolution: 300 DPI (publication-ready)")
        
        plt.close()
        
        # Print comparison report
        print("\n" + "="*70)
        print("MODEL PERFORMANCE COMPARISON")
        print("="*70)
        print(f"{'Metric':<30} | {'Single-Stage':<20} | {'Two-Stage':<20}")
        print("-" * 72)
        print(f"{'Mean RMSE':<30} | {stats_single['mean']:<20.4f} | {stats_two['mean']:<20.4f}")
        print(f"{'Median RMSE':<30} | {stats_single['median']:<20.4f} | {stats_two['median']:<20.4f}")
        print(f"{'Excellent Fit (<0.05)':<30} | {stats_single['excellent']:<20.1f}% | {stats_two['excellent']:<20.1f}%")
        print(f"{'Good Fit (<0.10)':<30} | {stats_single['good']:<20.1f}% | {stats_two['good']:<20.1f}%")
        print("-" * 72)
        
        improvement = ((stats_single['mean'] - stats_two['mean']) / stats_single['mean']) * 100
        print(f"\nRMSE Improvement: {improvement:.1f}%")
        print(f"Excellence Gain: {stats_two['excellent'] - stats_single['excellent']:.1f} percentage points")
        
        print("\n" + "="*70)
        print("CONCLUSION: The two-stage model significantly outperforms")
        print("            the single-stage model in capturing diagenetic trends.")
        print("="*70 + "\n")
        
    except Exception as e:
        print(f"\n[ERROR] {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("\nUsage: python comparative_analysis.py <input.csv> [output.png]")
        print("\nExample:")
        print("  python comparative_analysis.py samples.csv comparison.png")
        sys.exit(1)
    
    csv_file = sys.argv[1]
    output_file = sys.argv[2] if len(sys.argv) > 2 else 'model_comparison.png'
    
    main(csv_file, output_file)
