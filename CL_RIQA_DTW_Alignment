"""
CL-RIQA & DTW Alignment Protocol
=================================
Supplementary Software for Scientific Publication
Description:
This script implements cathodoluminescence (CL) image quality assessment (RIQA)
and Dynamic Time Warping (DTW) alignment protocol for correlating CL images
with elemental profiles.
Dependencies:
- Python >= 3.7
- numpy
- pandas
- matplotlib
- seaborn
- opencv-python (cv2)
- scipy
- scikit-learn
- fastdtw
Installation:
pip install numpy pandas matplotlib seaborn opencv-python scipy scikit-learn fastdtw
Usage:
Run this script in a standard Python environment. The script will prompt for
input files (CL image and CSV data) or you can modify the file loading section
to specify file paths directly.
Notes:
- This is a clean version for academic submission
- Personal information and platform-specific code have been removed
- All algorithms and parameters are preserved for reproducibility
"""
# =============================================================================
# Title: CL-RIQA & DTW Alignment Protocol
# =============================================================================
# --- 1. Environment Setup & Dependency Check ---
import fastdtw
import cv2
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
# Scientific computing libraries
from scipy.interpolate import interp1d
from scipy.spatial.distance import euclidean
from fastdtw import fastdtw
from sklearn.preprocessing import MinMaxScaler
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import cross_val_score, KFold
# Suppress minor warnings for clean output
warnings.filterwarnings('ignore')
# --- 2. Global Plotting Style Configuration (Journal Standard) ---
plt.rcParams.update({
'font.family': 'sans-serif',
'font.sans-serif': ['Arial', 'DejaVu Sans'],  # Priority: Arial
'font.size': 12,
'axes.linewidth': 1.2,       # Frame thickness
'xtick.major.width': 1.2,    # Tick thickness
'ytick.major.width': 1.2,
'xtick.direction': 'in',     # Ticks point inwards
'ytick.direction': 'in',
'axes.unicode_minus': False,
'savefig.bbox': 'tight',
'figure.dpi': 300            # High resolution for review
})
# =============================================================================
# Core Algorithms: Image Processing & Data Alignment
# =============================================================================
def extract_cl_intensity(file_bytes):
"""
Performs CL-RIQA (Reconstructed Image Quantitative Analysis).
Methodology:
1. Digital Spectral Separation: Extracts Red Channel (Mn-activation).
2. Denoising: Median filter (kernel=3) for electronic noise removal.
3. Standardization: Thresholding based on resin background (I_bg) and
normalization standard (I_std).
Args:
file_bytes (bytes): Raw image file bytes.
Returns:
np.array: 1D array of standardized CL intensity profiles.
"""
# Decode image
img = cv2.imdecode(np.asarray(bytearray(file_bytes), dtype=np.uint8), cv2.IMREAD_COLOR)
if img is None:
raise ValueError("Image decoding failed.")
# Parameters (Calibrated for 8-bit images)
I_BG = 20.0   # Background threshold (Resin)
I_STD = 200.0 # Normalization standard (Bright calcite reference)
# Processing
img_denoised = cv2.medianBlur(img, 3)
b, g, r = cv2.split(img_denoised)
# Masking: Red dominant & Intensity > Background
mask = (r > g) & (r > b) & (r > I_BG)
r_float = r.astype(np.float32)
# Vertical Integration (Profile Extraction)
profile = []
width = r.shape[1]
for col in range(width):
# Extract valid geological pixels in the column
valid_pixels = r_float[:, col][mask[:, col]]
if len(valid_pixels) > 0:
# Calculate Net Normalized Intensity: ((Mean - Bg) / Std) * 100
intensity = (max(0, np.mean(valid_pixels) - I_BG) / I_STD) * 100.0
profile.append(intensity)
else:
profile.append(0.0) # Handle voids/pure resin columns
return np.array(profile)
def perform_alignment(cl_data, ms_data, resolution_factor=5):
"""
Aligns multi-modal data using Dual Interpolation and Dynamic Time Warping (DTW).
Args:
cl_data (np.array): CL intensity profile.
ms_data (np.array): LA-ICP-MS ratio profile.
resolution_factor (int): Supersampling factor to suppress step artifacts.
Default=5 ensures smooth gradients.
Returns:
tuple: (cl_aligned, ms_aligned, cl_raw_interp, ms_raw_interp)
Returns both aligned and linearly interpolated (raw) datasets.
"""
# 1. Supersampling (Dual Linear Interpolation)
# Normalize length to the longest dataset * resolution_factor
target_len = max(len(cl_data), len(ms_data)) * resolution_factor
x_cl = np.linspace(0, 1, len(cl_data))
x_ms = np.linspace(0, 1, len(ms_data))
x_target = np.linspace(0, 1, target_len)
# Interpolate both to high-resolution grid
f_cl = interp1d(x_cl, cl_data, kind='linear')
f_ms = interp1d(x_ms, ms_data, kind='linear')
cl_high = f_cl(x_target)
ms_high = f_ms(x_target)
# 2. DTW Alignment
# Normalize features for distance calculation
scaler = MinMaxScaler()
cl_norm = scaler.fit_transform(cl_high.reshape(-1, 1)).flatten()
ms_norm = scaler.fit_transform(ms_high.reshape(-1, 1)).flatten()
# Compute Warping Path (Radius constraint prevents pathological warping)
# Input must be reshaped to (N, 1) for fastdtw
dist, path = fastdtw(cl_norm.reshape(-1, 1), ms_norm.reshape(-1, 1),
radius=int(target_len * 0.1),
dist=euclidean)
# Extract aligned indices
idx_cl = [p[0] for p in path]
idx_ms = [p[1] for p in path]
return cl_high[idx_cl], ms_high[idx_ms], cl_high, ms_high
def calculate_statistics(x, y):
"""
Computes statistical metrics for correlation validation.
Returns:
Linear R2: Coefficient of determination for OLS.
RF CV R2: 5-Fold Cross-Validation R2 for Random Forest (Robustness check).
Model: Trained LinearRegression model (for plotting).
"""
X_reshaped = x.reshape(-1, 1)
# Linear Regression
lin_model = LinearRegression().fit(X_reshaped, y)
r2_lin = lin_model.score(X_reshaped, y)
# Random Forest with Cross-Validation
rf_model = RandomForestRegressor(n_estimators=50, random_state=42)
kf = KFold(n_splits=5, shuffle=True, random_state=42)
cv_scores = cross_val_score(rf_model, X_reshaped, y, cv=kf, scoring='r2')
r2_rf_cv = cv_scores.mean()
return r2_lin, r2_rf_cv, lin_model
# =============================================================================
# Visualization & Export
# =============================================================================
def generate_publication_figure(cl_raw, ms_raw, cl_align, ms_align):
"""Generates a 2x2 comparison panel formatted for scientific publication."""
# Compute Stats
r2_raw_lin, r2_raw_rf, model_raw = calculate_statistics(ms_raw, cl_raw)
r2_aln_lin, r2_aln_rf, model_align = calculate_statistics(ms_align, cl_align)
# Figure Setup
fig, axes = plt.subplots(2, 2, figsize=(12, 10))
plt.subplots_adjust(wspace=0.3, hspace=0.35)
# Colors (Colorblind safe / High Contrast)
COL_CL = '#A93226'      # Dark Red
COL_MS = '#2980B9'      # Dark Blue
COL_DOT_RAW = 'gray'    # Gray for raw data
COL_DOT_ALN = '#27AE60' # Green for valid data
# --- Panel A: Spatial Profile (Raw/Misaligned) ---
ax1 = axes[0, 0]
ax1_r = ax1.twinx()
l1 = ax1.plot(cl_raw, color=COL_CL, lw=1.5, label='CL Intensity')
l2 = ax1_r.plot(ms_raw, color=COL_MS, lw=1.5, ls='--', label='Mn/Fe Ratio')
ax1.set_title("(a) Spatial Profile (Before Alignment)", loc='left', fontweight='bold')
ax1.set_xlabel("Normalized Distance")
ax1.set_ylabel("CL Index", color=COL_CL)
ax1_r.set_ylabel("Mn/Fe Ratio", color=COL_MS)
ax1.tick_params(axis='y', labelcolor=COL_CL)
ax1_r.tick_params(axis='y', labelcolor=COL_MS)
# --- Panel B: Spatial Profile (Aligned) ---
ax2 = axes[0, 1]
ax2_r = ax2.twinx()
ax2.plot(cl_align, color=COL_CL, lw=1.5)
ax2_r.plot(ms_align, color=COL_MS, lw=1.5, ls='--')
ax2.set_title("(b) Spatial Profile (After Alignment)", loc='left', fontweight='bold')
ax2.set_xlabel("Warped Index")
ax2.set_ylabel("CL Index", color=COL_CL)
ax2_r.set_ylabel("Mn/Fe Ratio", color=COL_MS)
ax2.tick_params(axis='y', labelcolor=COL_CL)
ax2_r.tick_params(axis='y', labelcolor=COL_MS)
# --- Panel C: Correlation (Raw) ---
ax3 = axes[1, 0]
# Downsample for scatter clarity
step_raw = max(1, len(ms_raw)//200)
ax3.scatter(ms_raw[::step_raw], cl_raw[::step_raw],
c='gray', alpha=0.6, s=40, edgecolors='black', linewidths=0.8)
# Plot Fit Line
x_range = np.linspace(ms_raw.min(), ms_raw.max(), 100).reshape(-1, 1)
ax3.plot(x_range, model_raw.predict(x_range), 'k--', lw=2)
ax3.set_title("(c) Correlation (Raw)", loc='left', fontweight='bold')
ax3.set_xlabel("Mn/Fe Ratio")
ax3.set_ylabel("CL Index")
# Stats Annotation
stats_text = f"Linear $R^2$ = {r2_raw_lin:.3f}\nRF CV $R^2$ = {r2_raw_rf:.3f}"
ax3.text(0.05, 0.95, stats_text, transform=ax3.transAxes, verticalalignment='top',
bbox=dict(boxstyle='round', facecolor='#f0f0f0', alpha=0.9), fontsize=10)
# --- Panel D: Correlation (Aligned) ---
ax4 = axes[1, 1]
step_aln = max(1, len(ms_align)//300)
# Style: Open circles (Facecolor='none') with Green edge
ax4.scatter(ms_align[::step_aln], cl_align[::step_aln],
facecolors='none', edgecolors=COL_DOT_ALN,
linewidths=1.2, s=40, alpha=0.7)
# Plot Fit Line
x_range_aln = np.linspace(ms_align.min(), ms_align.max(), 100).reshape(-1, 1)
ax4.plot(x_range_aln, model_align.predict(x_range_aln), 'k--', lw=2)
ax4.set_title("(d) Correlation (Aligned)", loc='left', fontweight='bold')
ax4.set_xlabel("Mn/Fe Ratio")
ax4.set_ylabel("CL Index")
# Stats Annotation
stats_text_aln = f"Linear $R^2$ = {r2_aln_lin:.3f}\nRF CV $R^2$ = {r2_aln_rf:.3f}"
ax4.text(0.05, 0.95, stats_text_aln, transform=ax4.transAxes, verticalalignment='top',
bbox=dict(boxstyle='round', facecolor='#d4edda', alpha=0.9), fontsize=10)
return fig
def export_data(cl_raw, ms_raw, cl_align, ms_align):
"""Exports processed data to CSV for external plotting (e.g., Origin/CorelDraw)."""
# Pad arrays to equal length with NaNs for single-file export
max_len = max(len(ms_raw), len(ms_align))
def pad(arr):
return np.pad(arr, (0, max_len - len(arr)), mode='constant', constant_values=np.nan)
df = pd.DataFrame({
'Raw_MnFe': pad(ms_raw),
'Raw_CL_Index': pad(cl_raw),
'Aligned_MnFe': pad(ms_align),
'Aligned_CL_Index': pad(cl_align)
})
filename = "CL_MS_Comparison_Data.csv"
df.to_csv(filename, index=False)
files.download(filename)
print(f"[Export] Data saved to {filename}")
# =============================================================================
# Main Execution Flow
# =============================================================================
def main():
print("=== Carbonate CL-MS Alignment Protocol ===")
# 1. Image Upload
print("Please ensure input files are in the working directory")
img_upload = files.upload()
if not img_upload:
print("Please ensure input files are in the working directory")
return
fname_img = next(iter(img_upload))
cl_intensity = extract_cl_intensity(img_upload[fname_img])
print(f" -> Processed CL Image: {len(cl_intensity)} profile points.")
# 2. Data Upload
print("Please ensure input files are in the working directory")
csv_upload = files.upload()
if not csv_upload:
print("Please ensure input files are in the working directory")
return
fname_csv = next(iter(csv_upload))
try:
df = pd.read_csv(io.BytesIO(csv_upload[fname_csv]))
except:
df = pd.read_csv(io.BytesIO(csv_upload[fname_csv]), sep=';')
# Check column name (Mn/Fe)
target_col = 'Mn/Fe'
if target_col not in df.columns:
print(f"Error: Column '{target_col}' not found in CSV.")
return
ms_ratio = pd.to_numeric(df[target_col], errors='coerce').dropna().values
print(f" -> Loaded MS Data: {len(ms_ratio)} data points.")
# 3. Alignment
print("\n[Step 3] Performing DTW Alignment...")
cl_aln, ms_aln, cl_raw_interp, ms_raw_interp = perform_alignment(cl_intensity, ms_ratio)
# 4. Visualization & Export
print("\n[Step 4] Generating Figures & Exporting Data...")
fig = generate_publication_figure(cl_raw_interp, ms_raw_interp, cl_aln, ms_aln)
# Save vectors
fig.savefig("Figure_Comparison.svg", format='svg')
fig.savefig("Figure_Comparison.pdf", format='pdf')
plt.show()
# Trigger downloads
files.download("Figure_Comparison.svg")
files.download("Figure_Comparison.pdf")
export_data(cl_raw_interp, ms_raw_interp, cl_aln, ms_aln)
print("\n=== Processing Complete ===")
if __name__ == "__main__":
main()
